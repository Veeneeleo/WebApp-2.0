<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>DVS Crates</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    header { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .pill { padding:6px 10px; border-radius:999px; background:#eee; }
    .good{ background:#d6ffe0; } .warn{ background:#fff2c9; } .bad{ background:#ffd6d6; }
    .card { border:1px solid #ddd; border-radius:12px; padding:12px; margin:12px 0; }
    .row { display:flex; gap:10px; justify-content:space-between; align-items:flex-start; padding:10px 0; border-bottom:1px solid #eee; }
    button,input,select { padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff; }
    button:disabled { opacity:0.5; }
    input[type="text"], input[type="password"] { width:min(520px,100%); }
    small { opacity:0.7; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 12px; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 10px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }
    .muted { opacity: 0.75; }
    .btnRow { display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .chip { display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f3f3; font-size:12px; }
    .danger { border-color:#f3b3b3; }
    .hint { margin-top:6px; }
    progress { width:100%; height:18px; }
    .tiny { font-size: 11px; }
  </style>
</head>
<body>
  <header>
    <h1>DVS Crates</h1>
    <div id="vinylPill" class="pill">VINYL: unknown</div>
  </header>

  <div class="grid">
    <section class="card">
      <h2>1) Connect to Raspberry Pi (BLE)</h2>

      <div class="row">
        <div>
          <b>Bluetooth</b><br/>
          <small>iOS: use Bluefy + HTTPS (GitHub Pages is fine).</small>
        </div>
        <div class="btnRow">
          <button id="bleConnectBtn">Connect</button>
          <button id="bleDisconnectBtn" disabled>Disconnect</button>
        </div>
      </div>

      <div class="row">
        <div>
          <b>Status</b><br/>
          <small>Polls STATUS from Pi → updates VINYL pill.</small>
        </div>
        <div class="btnRow">
          <button id="statusBtn" disabled>STATUS</button>
          <button id="startPollBtn" disabled>Start Poll</button>
          <button id="stopPollBtn" disabled>Stop Poll</button>
        </div>
      </div>

      <div class="mono" id="bleLog" style="white-space:pre-wrap; max-height:260px; overflow:auto;"></div>
      <div class="muted"><small id="env"></small></div>
    </section>

    <section class="card">
      <h2>2) Wi-Fi on Pi (via BLE)</h2>

      <div class="row">
        <div>
          <b>Scan + Join</b><br/>
          <small>Only needed for SpotDL downloads. Turn Wi-Fi off for performance mode.</small>
        </div>
        <div class="btnRow">
          <button id="wifiScanBtn" disabled>Scan</button>
          <button id="wifiStatusBtn" disabled>Status</button>
          <button id="wifiOffBtn" disabled>Wi-Fi Off</button>
        </div>
      </div>

      <div class="row" style="border-bottom:none;">
        <div style="width:100%;">
          <div class="muted hint"><small>Networks (top 25 by signal):</small></div>
          <select id="wifiSsid" style="width:min(520px,100%);" disabled>
            <option value="">(scan first)</option>
          </select>
          <div class="hint"></div>
          <input id="wifiPass" type="password" placeholder="Wi-Fi password (leave blank if open)" disabled />
          <div class="btnRow" style="margin-top:10px;">
            <button id="wifiJoinBtn" disabled>Join</button>
          </div>

          <div class="muted hint">
            <small>
              State: <span id="wifiState">unknown</span>
              &nbsp; | &nbsp; IP: <span id="wifiIp">-</span>
            </small>
          </div>
        </div>
      </div>
    </section>
  </div>

  <div class="grid">
    <section class="card">
      <h2>3) Spotify Login + Search</h2>

      <div class="row">
        <div>
          <b>Spotify</b><br/>
          <small>Auto-search while typing. Tracks &gt; 10 min are disabled.</small>
        </div>
        <div class="btnRow">
          <button id="spotifyLoginBtn">Login</button>
          <button id="spotifyLogoutBtn">Logout</button>
        </div>
      </div>

      <div id="me" class="muted"></div>

      <div class="row" style="border-bottom:none;">
        <div style="width:100%;">
          <input id="searchBox" type="text" placeholder="Type to search tracks…" />
          <div class="muted hint"><small id="searchHint"></small></div>
          <div class="muted hint">
            <small><b>Crate cap:</b> total ≤ 10:00. Current crate: <span id="crateDurLabel">0:00</span></small>
          </div>
        </div>
      </div>

      <div id="results"></div>
    </section>

    <section class="card">
      <h2>4) Download progress (SpotDL on Pi)</h2>

      <div class="row" id="dlRow" style="display:none; border-bottom:none;">
        <div style="width:100%;">
          <b>Downloading on Pi…</b> <span class="chip" id="dlPct">0%</span><br/>
          <progress id="dlProg" value="0" max="100"></progress>
          <div class="muted"><small id="dlMsg"></small></div>
        </div>
      </div>

      <div class="muted tiny">
        <small>
          This progress comes from Pi notifications: DL_MSG / DL_PCT / DL_DONE / DL_ERR.
        </small>
      </div>
    </section>
  </div>

  <section class="card">
    <h2>5) Current Playlist (Crate)</h2>

    <div class="row">
      <div>
        <b>Selected tracks</b> <span class="chip" id="selectedCount">0</span><br/>
        <small>Crate duration must stay ≤ 10:00 total.</small>
      </div>
      <div class="btnRow">
        <button id="clearSelectedBtn">Clear</button>
      </div>
    </div>

    <ol id="selected"></ol>

    <div class="row" style="border-bottom:none;">
      <input id="crateName" type="text" placeholder="Crate name (e.g., My Set 1)" />
      <div class="btnRow">
        <button id="saveCrateBtn">Save Crate</button>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>6) Saved Crates</h2>

    <div class="row">
      <div>
        <b>Your crates</b><br/>
        <small>Stored in localStorage on your phone.</small>
      </div>
      <div class="btnRow">
        <button id="refreshCratesBtn">Refresh</button>
      </div>
    </div>

    <ul id="crates"></ul>
  </section>

<script>
/* ======================== CHANGE ME (Spotify) ======================== */
const SPOTIFY_CLIENT_ID = "81cff1fc219b442abfb47d9a3bba8960"; // <- put your real client id
const REDIRECT_URI = "https://veeneeleo.github.io/WebApp-2.0/";
// must match Spotify dashboard EXACTLY
const SCOPES = ["user-read-email"];
const CRATE_MAX_MS = 10 * 60 * 1000;   // <= 10 minutes TOTAL
/* ================================================================ */

/* ======================== BLE Nordic UART UUIDs ======================== */
const UART_SERVICE_UUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
const UART_RX_UUID      = "6e400002-b5a3-f393-e0a9-e50e24dcca9e"; // write
const UART_TX_UUID      = "6e400003-b5a3-f393-e0a9-e50e24dcca9e"; // notify
/* ================================================================ */

const $ = (id) => document.getElementById(id);

function logBle(msg) { $("bleLog").textContent = msg + "\n" + $("bleLog").textContent; }
function setVinylPill({ ready, lock }) {
  const pill = $("vinylPill");
  if (ready) { pill.className="pill good"; pill.textContent="VINYL: READY"; }
  else if (lock) { pill.className="pill warn"; pill.textContent="VINYL: LOCKED"; }
  else { pill.className="pill bad"; pill.textContent="VINYL: NO LOCK"; }
}
function enc(str){ return new TextEncoder().encode(str); }

/* ======================== Local crate storage ======================== */
const LS_KEY = "dvs_crates_v4";
function loadCrates(){ try { return JSON.parse(localStorage.getItem(LS_KEY) || "[]"); } catch { return []; } }
function saveCrates(crates){ localStorage.setItem(LS_KEY, JSON.stringify(crates)); }
/* ================================================================ */

/* ======================== Download UI ======================== */
function showDlUI(show){ $("dlRow").style.display = show ? "" : "none"; }
function setDlProgress(pct, msg){
  pct = Math.max(0, Math.min(100, pct|0));
  $("dlProg").value = pct;
  $("dlPct").textContent = pct + "%";
  $("dlMsg").textContent = msg || "";
}
/* ================================================================ */

/* ======================== Wi-Fi UI ======================== */
let wifiNets = []; // {ssid, signal}
function wifiSetEnabled(en){
  $("wifiScanBtn").disabled = !en;
  $("wifiStatusBtn").disabled = !en;
  $("wifiOffBtn").disabled = !en;
  $("wifiSsid").disabled = !en;
  $("wifiPass").disabled = !en;
  $("wifiJoinBtn").disabled = !en;
}
function wifiRenderNets(){
  const sel = $("wifiSsid");
  sel.innerHTML = "";
  if (!wifiNets.length){
    const opt = document.createElement("option");
    opt.value = "";
    opt.textContent = "(no networks yet — tap Scan)";
    sel.appendChild(opt);
    return;
  }
  const opt0 = document.createElement("option");
  opt0.value = "";
  opt0.textContent = "(choose a network)";
  sel.appendChild(opt0);

  wifiNets.forEach(n => {
    const opt = document.createElement("option");
    opt.value = n.ssid;
    opt.textContent = `${n.ssid} (${n.signal}%)`;
    sel.appendChild(opt);
  });
}
function wifiSetState(state, ip=""){
  $("wifiState").textContent = state || "unknown";
  $("wifiIp").textContent = ip || "-";
}
/* ================================================================ */

/* ======================== BLE client ======================== */
let ble = {
  device:null, server:null, rx:null, tx:null,
  connected:false,
  notifyBuf:"",
  lastStatus:{ready:false, lock:false, posMs:0, rate:1.0},
  pollTimer:null,
};

function setBleUi(connected) {
  $("bleConnectBtn").disabled = connected;
  $("bleDisconnectBtn").disabled = !connected;
  $("statusBtn").disabled = !connected;
  $("startPollBtn").disabled = !connected;
  $("stopPollBtn").disabled = !connected;
  wifiSetEnabled(connected);
}

async function bleWriteLine(line) {
  if (!ble.connected) throw new Error("BLE not connected");
  if (!line.endsWith("\n")) line += "\n";
  const data = enc(line);
  if (ble.rx.writeValueWithoutResponse) await ble.rx.writeValueWithoutResponse(data);
  else await ble.rx.writeValue(data);
}

function onBleText(text) {
  ble.notifyBuf += text;
  let idx;
  while ((idx = ble.notifyBuf.indexOf("\n")) >= 0) {
    const line = ble.notifyBuf.slice(0, idx).trim();
    ble.notifyBuf = ble.notifyBuf.slice(idx + 1);
    if (!line) continue;

    // ---- dvs_core STATUS parsing ----
    if (line.startsWith("READY ")) ble.lastStatus.ready = line.endsWith("1");
    else if (line.startsWith("LOCK ")) ble.lastStatus.lock = line.endsWith("1");
    else if (line.startsWith("POS_MS ")) ble.lastStatus.posMs = parseInt(line.slice(7), 10) || 0;
    else if (line.startsWith("RATE ")) ble.lastStatus.rate = parseFloat(line.slice(5)) || 0;
    else if (line === ".") setVinylPill({ ready: ble.lastStatus.ready, lock: ble.lastStatus.lock });

    // ---- SpotDL progress parsing ----
    else if (line.startsWith("DL_PCT ")) {
      const pct = parseInt(line.slice(7), 10) || 0;
      showDlUI(true);
      setDlProgress(pct, $("dlMsg").textContent);
    }
    else if (line.startsWith("DL_MSG ")) {
      const msg = line.slice(7);
      showDlUI(true);
      setDlProgress(parseInt($("dlProg").value,10)||0, msg);
    }
    else if (line === "DL_DONE") {
      setDlProgress(100, "Done.");
      setTimeout(()=>showDlUI(false), 1500);
    }
    else if (line.startsWith("DL_ERR ")) {
      showDlUI(true);
      setDlProgress(parseInt($("dlProg").value,10)||0, "Error: " + line.slice(7));
      alert("Download failed: " + line.slice(7));
    }

    // ---- Wi-Fi parsing ----
    else if (line.startsWith("WIFI_NET ")) {
      // WIFI_NET ssid|signal
      const payload = line.slice(9);
      const [ssid, sig] = payload.split("|");
      const signal = parseInt(sig || "0", 10) || 0;
      if (ssid && ssid.trim()) {
        // avoid duplicates, keep best signal
        const s = ssid.trim();
        const i = wifiNets.findIndex(x => x.ssid === s);
        if (i >= 0) wifiNets[i].signal = Math.max(wifiNets[i].signal, signal);
        else wifiNets.push({ssid: s, signal});
      }
    }
    else if (line === "WIFI_SCAN_DONE") {
      wifiNets.sort((a,b)=>b.signal-a.signal);
      wifiRenderNets();
      logBle("Wi-Fi scan done.");
    }
    else if (line.startsWith("WIFI_STATE ")) {
      wifiSetState(line.slice(11), $("wifiIp").textContent === "-" ? "" : $("wifiIp").textContent);
    }
    else if (line.startsWith("WIFI_IP ")) {
      wifiSetState($("wifiState").textContent, line.slice(8).trim());
    }
    else if (line.startsWith("WIFI_ERR ")) {
      alert("Wi-Fi error: " + line.slice(9));
    }

    logBle(line);
  }
}

async function bleConnect() {
  if (!window.isSecureContext) alert("Not secure context. Must be HTTPS.");
  if (!navigator.bluetooth) alert("navigator.bluetooth not available in this browser.");

  ble.device = await navigator.bluetooth.requestDevice({
    filters: [{ services: [UART_SERVICE_UUID] }],
  });

  ble.server = await ble.device.gatt.connect();
  const svc = await ble.server.getPrimaryService(UART_SERVICE_UUID);
  ble.rx = await svc.getCharacteristic(UART_RX_UUID);
  ble.tx = await svc.getCharacteristic(UART_TX_UUID);

  await ble.tx.startNotifications();
  ble.tx.addEventListener("characteristicvaluechanged", (ev) => {
    const v = ev.target.value;
    const bytes = new Uint8Array(v.buffer);
    onBleText(new TextDecoder().decode(bytes));
  });

  ble.connected = true;
  setBleUi(true);
  refreshCrates();
  logBle("BLE connected. Tap STATUS.");
}

async function bleDisconnect() {
  stopPoll();
  try { if (ble.device?.gatt?.connected) ble.device.gatt.disconnect(); } catch {}
  ble.connected = false;
  setBleUi(false);
  refreshCrates();
  logBle("BLE disconnected.");
}

async function statusOnce(){ await bleWriteLine("STATUS"); }

function startPoll() {
  stopPoll();
  ble.pollTimer = setInterval(() => {
    if (ble.connected) bleWriteLine("STATUS").catch(()=>{});
  }, 300);
  logBle("Polling STATUS…");
}

function stopPoll() {
  if (ble.pollTimer) clearInterval(ble.pollTimer);
  ble.pollTimer = null;
  logBle("Stopped polling.");
}
/* ================================================================ */

/* ======================== Spotify PKCE ======================== */
function base64urlencode(a) {
  return btoa(String.fromCharCode(...new Uint8Array(a)))
    .replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function sha256(plain) {
  return crypto.subtle.digest("SHA-256", new TextEncoder().encode(plain));
}
function randomString(len = 64) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let s = "";
  for (let i=0;i<len;i++) s += chars[Math.floor(Math.random()*chars.length)];
  return s;
}
function spotifyToken(){ return localStorage.getItem("spotify_token"); }

async function spotifyLogin() {
  if (SPOTIFY_CLIENT_ID === "CHANGE_ME" || !SPOTIFY_CLIENT_ID.trim()) {
    alert("Set SPOTIFY_CLIENT_ID at the top of the HTML first.");
    return;
  }
  const verifier = randomString(96);
  const challenge = base64urlencode(await sha256(verifier));
  localStorage.setItem("pkce_verifier", verifier);

  const args = new URLSearchParams({
    client_id: SPOTIFY_CLIENT_ID,
    response_type: "code",
    redirect_uri: REDIRECT_URI,
    code_challenge_method: "S256",
    code_challenge: challenge,
    scope: SCOPES.join(" "),
  });

  location.href = `https://accounts.spotify.com/authorize?${args.toString()}`;
}

async function exchangeCodeForToken(code) {
  const verifier = localStorage.getItem("pkce_verifier");
  const body = new URLSearchParams({
    client_id: SPOTIFY_CLIENT_ID,
    grant_type: "authorization_code",
    code,
    redirect_uri: REDIRECT_URI,
    code_verifier: verifier,
  });

  const r = await fetch("https://accounts.spotify.com/api/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body,
  });
  const data = await r.json();
  if (!r.ok) throw new Error(JSON.stringify(data));
  localStorage.setItem("spotify_token", data.access_token);
  history.replaceState({}, document.title, REDIRECT_URI);
  return data.access_token;
}

function spotifyLogout() {
  localStorage.removeItem("spotify_token");
  $("me").textContent = "";
  clearResults();
  $("searchHint").textContent = "";
  alert("Logged out.");
}

async function spotifyGET(path) {
  const token = spotifyToken();
  if (!token) throw new Error("Not logged in");
  const r = await fetch(`https://api.spotify.com/v1${path}`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  const data = await r.json();
  if (!r.ok) throw new Error(JSON.stringify(data));
  return data;
}

async function loadMe() {
  const me = await spotifyGET("/me");
  $("me").textContent = `Logged in as: ${me.display_name || me.id}`;
}
/* ================================================================ */

/* ======================== Auto search + crate cap + hide results ======================== */
const selected = []; // current in-progress crate
let lastSearchItems = []; // keep items so we can re-render button state

function fmtDur(ms){
  const s = Math.round(ms/1000);
  const m = Math.floor(s/60);
  const r = s % 60;
  return `${m}:${String(r).padStart(2,'0')}`;
}
function crateTotalMs(){
  return selected.reduce((acc, t) => acc + (t.duration_ms || 0), 0);
}
function updateCrateDurLabel(){
  $("crateDurLabel").textContent = fmtDur(crateTotalMs());
}

function isAlreadySelected(trackId){
  return selected.some(t => t.id === trackId);
}

function canAddTrack(track){
  if (!track) return false;
  if (track.duration_ms > CRATE_MAX_MS) return false; // a single track can't exceed cap
  const nextTotal = crateTotalMs() + track.duration_ms;
  return nextTotal <= CRATE_MAX_MS;
}

function renderSelected(){
  $("selectedCount").textContent = String(selected.length);
  updateCrateDurLabel();

  const ol = $("selected");
  ol.innerHTML = "";
  selected.forEach((t, idx) => {
    const li = document.createElement("li");
    li.className = "row";
    li.style.borderBottom = "1px solid #eee";
    li.innerHTML = `
      <div style="max-width:70%;">
        <b>${t.name}</b> — ${t.artist}<br/>
        <small>${fmtDur(t.duration_ms)}</small>
      </div>
      <div class="btnRow">
        <button data-act="up">↑</button>
        <button data-act="down">↓</button>
        <button class="danger" data-act="remove">Remove</button>
      </div>
    `;
    li.querySelector('[data-act="up"]').onclick = () => {
      if (idx === 0) return;
      const tmp = selected[idx-1]; selected[idx-1] = selected[idx]; selected[idx] = tmp;
      renderSelected();
      renderResults(lastSearchItems);
    };
    li.querySelector('[data-act="down"]').onclick = () => {
      if (idx === selected.length-1) return;
      const tmp = selected[idx+1]; selected[idx+1] = selected[idx]; selected[idx] = tmp;
      renderSelected();
      renderResults(lastSearchItems);
    };
    li.querySelector('[data-act="remove"]').onclick = () => {
      selected.splice(idx, 1);
      renderSelected();
      renderResults(lastSearchItems);
    };
    ol.appendChild(li);
  });
}

function clearResults(){
  lastSearchItems = [];
  $("results").innerHTML = "";
}

function renderResults(items){
  lastSearchItems = items || [];
  const root = $("results");
  root.innerHTML = "";
  if (!items || !items.length) return;

  const total = crateTotalMs();

  items.forEach((t) => {
    const tooLong = t.duration_ms > CRATE_MAX_MS;
    const already = isAlreadySelected(t.id);
    const wouldExceed = !already && (total + t.duration_ms > CRATE_MAX_MS);

    const row = document.createElement("div");
    row.className = "row";
    row.innerHTML = `
      <div style="max-width:70%;">
        <b>${t.name}</b> — ${t.artist}<br/>
        <small>${fmtDur(t.duration_ms)}
          ${tooLong ? "(too long)" : ""}
          ${wouldExceed ? "(crate full)" : ""}
        </small>
      </div>
      <div class="btnRow">
        <button ${tooLong || already || wouldExceed ? "disabled" : ""}>
          ${already ? "Added" : (wouldExceed ? "Full" : "Add")}
        </button>
      </div>
    `;

    row.querySelector("button").onclick = () => {
      if (tooLong) return;
      if (already) return;
      if (!canAddTrack(t)) {
        alert("Crate limit is 10:00 total. Remove something or pick a shorter track.");
        return;
      }
      selected.push(t);
      renderSelected();
      renderResults(items);
    };

    root.appendChild(row);
  });
}

let searchTimer = null;
let lastQuery = "";
let blurHideTimer = null;

async function doSearchAuto(q){
  if (!spotifyToken()) {
    $("searchHint").textContent = "Login to Spotify to search.";
    clearResults();
    return;
  }
  q = q.trim();
  if (q.length < 2) {
    $("searchHint").textContent = "Type at least 2 characters.";
    clearResults();
    return;
  }
  if (q === lastQuery) return;
  lastQuery = q;

  $("searchHint").textContent = "Searching…";
  try {
    const data = await spotifyGET(`/search?type=track&limit=20&q=${encodeURIComponent(q)}`);
    const items = data.tracks.items.map(tr => ({
      id: tr.id,
      uri: tr.uri,
      name: tr.name,
      artist: tr.artists?.[0]?.name ?? "Unknown",
      duration_ms: tr.duration_ms,
    }));
    $("searchHint").textContent = `Results for: "${q}" (tap outside to hide)`;
    renderResults(items);
  } catch (e) {
    $("searchHint").textContent = "Search failed (check login).";
    console.error(e);
  }
}

function onSearchInput(){
  const q = $("searchBox").value;
  if (searchTimer) clearTimeout(searchTimer);
  searchTimer = setTimeout(() => doSearchAuto(q), 250);
}

/* Hide results when leaving search bar, but allow tapping results */
function onSearchBlur(){
  if (blurHideTimer) clearTimeout(blurHideTimer);
  blurHideTimer = setTimeout(() => {
    clearResults();
    $("searchHint").textContent = "";
  }, 200);
}
function onSearchFocus(){
  if (blurHideTimer) clearTimeout(blurHideTimer);
  blurHideTimer = null;
  if (spotifyToken()) {
    $("searchHint").textContent = "Type to search (results auto-hide when you tap outside).";
  }
}

function saveCrate(){
  const name = $("crateName").value.trim();
  if (!name) return alert("Enter a crate name.");
  if (!selected.length) return alert("Add some tracks first.");

  const total = crateTotalMs();
  if (total > CRATE_MAX_MS) {
    alert("Crate total exceeds 10:00. Remove tracks until it's under 10:00.");
    return;
  }

  const crates = loadCrates();
  crates.unshift({
    id: crypto.randomUUID(),
    name,
    tracks: [...selected],
    total_ms: total,
    createdAt: Date.now(),
  });
  saveCrates(crates);

  selected.length = 0;
  renderSelected();
  $("crateName").value = "";
  refreshCrates();
  alert("Crate saved on this phone.");
}

function refreshCrates(){
  const crates = loadCrates();
  const ul = $("crates");
  ul.innerHTML = "";

  crates.forEach((c) => {
    const li = document.createElement("li");
    li.className = "row";
    li.innerHTML = `
      <div style="max-width:70%;">
        <b>${c.name}</b>
        <span class="chip">${c.tracks.length} tracks</span>
        <span class="chip">${fmtDur(c.total_ms || c.tracks.reduce((a,t)=>a+(t.duration_ms||0),0))}</span><br/>
        <small>${new Date(c.createdAt).toLocaleString()}</small>
      </div>
      <div class="btnRow">
        <button data-act="send" ${ble.connected ? "" : "disabled"}>Send + Download</button>
        <button data-act="load">Load</button>
        <button class="danger" data-act="del">Delete</button>
      </div>
    `;

    li.querySelector('[data-act="send"]').onclick = async () => {
      if (!ble.connected) return alert("Connect BLE first.");

      showDlUI(true);
      setDlProgress(0, "Sending crate to Pi…");

      const safe = (s)=>String(s||"").replace(/\|/g," ").replace(/\n/g," ").trim();

      await bleWriteLine(`CRATE_BEGIN ${safe(c.name)}`);
      await bleWriteLine(`CRATE_TOTAL_MS ${c.total_ms || 0}`);
      for (const t of c.tracks) {
        await bleWriteLine(`CRATE_TRACK ${safe(t.id)}|${t.duration_ms||0}|${safe(t.uri)}|${safe(t.name)}|${safe(t.artist)}`);
      }
      await bleWriteLine("CRATE_END");

      setDlProgress(0, "Starting SpotDL on Pi…");
      await bleWriteLine(`DL_START ${safe(c.name)}`);

      // Progress will update from DL_MSG/DL_PCT
    };

    li.querySelector('[data-act="load"]').onclick = () => {
      selected.length = 0;
      c.tracks.forEach(t => selected.push(t));
      renderSelected();
      $("crateName").value = c.name;
      alert("Crate loaded into Current Playlist.");
    };

    li.querySelector('[data-act="del"]').onclick = () => {
      if (!confirm(`Delete crate "${c.name}"?`)) return;
      const next = crates.filter(x => x.id !== c.id);
      saveCrates(next);
      refreshCrates();
    };

    ul.appendChild(li);
  });
}
/* ================================================================ */

/* ======================== Wi-Fi actions ======================== */
async function wifiScan(){
  if (!ble.connected) return alert("Connect BLE first.");
  wifiNets = [];
  wifiRenderNets();
  wifiSetState("scanning", "");
  await bleWriteLine("WIFI_SCAN");
}
async function wifiJoin(){
  if (!ble.connected) return alert("Connect BLE first.");
  const ssid = $("wifiSsid").value;
  const pwd = $("wifiPass").value;
  if (!ssid) return alert("Choose a network SSID first.");
  wifiSetState("connecting", "");
  // format: WIFI_JOIN ssid|password
  await bleWriteLine(`WIFI_JOIN ${ssid}|${pwd}`);
}
async function wifiStatus(){
  if (!ble.connected) return alert("Connect BLE first.");
  await bleWriteLine("WIFI_STATUS");
}
async function wifiOff(){
  if (!ble.connected) return alert("Connect BLE first.");
  await bleWriteLine("WIFI_OFF");
}
/* ================================================================ */

/* ======================== Wire UI ======================== */
$("bleConnectBtn").onclick = async () => {
  try {
    await bleConnect();
  } catch (e) {
    console.error("BLE connect error:", e);
    alert("BLE connect error:\n" +
      "name=" + (e?.name || "n/a") + "\n" +
      "message=" + (e?.message || String(e)) + "\n" +
      "code=" + (e?.code ?? "n/a"));
  }
};
$("bleDisconnectBtn").onclick = () => bleDisconnect();

$("statusBtn").onclick = () => statusOnce().catch(e => alert("STATUS error: " + (e?.message || e)));
$("startPollBtn").onclick = () => startPoll();
$("stopPollBtn").onclick = () => stopPoll();

$("wifiScanBtn").onclick = () => wifiScan().catch(e => alert("Wi-Fi scan error: " + (e?.message || e)));
$("wifiJoinBtn").onclick = () => wifiJoin().catch(e => alert("Wi-Fi join error: " + (e?.message || e)));
$("wifiStatusBtn").onclick = () => wifiStatus().catch(e => alert("Wi-Fi status error: " + (e?.message || e)));
$("wifiOffBtn").onclick = () => wifiOff().catch(e => alert("Wi-Fi off error: " + (e?.message || e)));

$("spotifyLoginBtn").onclick = () => spotifyLogin().catch(e => alert("Spotify login error: " + (e?.message || e)));
$("spotifyLogoutBtn").onclick = () => spotifyLogout();

$("searchBox").addEventListener("input", onSearchInput);
$("searchBox").addEventListener("blur", onSearchBlur);
$("searchBox").addEventListener("focus", onSearchFocus);

$("saveCrateBtn").onclick = () => saveCrate();
$("refreshCratesBtn").onclick = () => refreshCrates();
$("clearSelectedBtn").onclick = () => {
  selected.length = 0;
  renderSelected();
  renderResults(lastSearchItems);
};
/* ================================================================ */

/* ======================== Boot ======================== */
setBleUi(false);
wifiRenderNets();
renderSelected();
refreshCrates();

(async function boot(){
  $("env").textContent =
    `secureContext=${window.isSecureContext} | navigator.bluetooth=${!!navigator.bluetooth} | redirect=${REDIRECT_URI}`;

  const url = new URL(location.href);
  const code = url.searchParams.get("code");
  if (code) {
    try { await exchangeCodeForToken(code); }
    catch(e){ alert("Spotify token exchange failed. Check Redirect URI + Client ID.\n" + e); }
  }
  if (spotifyToken()) {
    try { await loadMe(); } catch {}
    $("searchHint").textContent = "Type to search (results auto-hide when you tap outside).";
  } else {
    $("searchHint").textContent = "Login to Spotify to search.";
  }
})();
</script>
</body>
</html>
